#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Mar 13 17:15:56 2021
@author: leonardobossi1
"""

import numpy as np
import random as rnd
from scipy.stats import norm
import matplotlib.pyplot as plt

re = 2.8179 * 10 ** -15 # Constant used when computing the cross sectional area.


def photon_E(E_initial, theta, e_rest = 511):
    E_final = E_initial / (1 + (E_initial * (1 - np.cos(theta)) / e_rest))
    
    return E_final 

def Gaussian(x, const, sigma, u):
    '''
    Returns Guassian function for a given x value and Gaussian parameters.
    sigma::float
        Standard deviation
    const::float
        constant
    u::float
        mean value
    '''
    return (const / (sigma * np.sqrt(2 * np.pi))) * np.e ** (-0.5 * ((x - u) / sigma) ** 2)


def analogsignal(angle, e0, gain, e_energy=511):
    
    # Calculating the scattering energy from the Compton relation
    energymeasure = e0 / (1 + (e0 / e_energy) * (1 - np.cos(np.deg2rad(angle))))
    
    # Computing the analog signal by multiplying the gain.
    analogsignal = energymeasure * gain

    return analogsignal


def theta_detector(r, diam = 50.8e-3):
    '''
    Returns angluar range of the detector.
    '''
    
    dtheta = 2 * np.arctan(diam / (2 * r))
    
    return dtheta

    

def backscatter(energy, gain):
    seed = rnd.random()
    angle = norm.ppf(seed, loc=180, scale=45) # angle choosing in degrees
    signalmeasured = analogsignal(angle, energy, gain)

    return signalmeasured


def cross_diff(theta, E_initial, re = re):
    
    E_scatter = photon_E(E_initial, theta)
    P = E_scatter / E_initial    
    
    cross_diff = 1/2 * (re ** 2) * (P ** 2) * (P + 1/P - (np.sin(theta)) ** 2)
    
    return cross_diff

    
def MC_int(func, theta_p, theta_m, N = 1000):
    '''
    Params::
        func:: function
            Function being integrated
        theta_p:: float
        theta_m:: float
            Upper and lower limits to be integreated over.
        N::int
            Number of iterations
    Returns::
        int_val:float
            Value of integral 
        err_val:float
            Associated uncertainty.
    '''
    int_vol = 2 * np.pi * (np.cos(theta_m) - np.cos(theta_p))
    int_vals = []
    
    for i in range(N):
        dtheta = theta_p - theta_m
        theta = theta_m + rnd.random() * dtheta
        
        int_vals.append(func(theta, 662))
        
    
    err = int_vol * np.std(int_vals) / np.sqrt(N)    
    integral_est = (int_vol / N) * sum(int_vals)

    
    return integral_est, err
    
    
theta_range = np.arange(0, np.pi, 0.01)
cross_sec = []

for theta_val in theta_range:
    theta_p = theta_val
    theta_m = 0
    
   
    cross_sec.append(MC_int(cross_diff, theta_p, theta_m)[0])
    
plt.scatter(theta_range, cross_sec)
plt.xlabel('Total angle integrated over')
plt.ylabel('Total cross section')
plt.grid()
plt.ylim(0, 4e-29)


def generate_noise(N, analogsig, gain, det_res=0.075, max_signal=5, bit_depth=9, probback = 0, scat_prob = 0):

    bins = {}

    for i in range(2 ** bit_depth):
        bins[i] = 0

    for i in range(N):

        seed = rnd.random()
        noise_signal = norm.ppf(seed, loc=0, scale=det_res * max_signal / 2) # Gaussian noise

        probscatt_n = rnd.random()
        backprob_n = rnd.random()
        
        
        if probscatt_n <= scat_prob:
            seed = rnd.random()
            angle = norm.ppf(seed, loc=180, scale=180)  # angle choosing in degrees [don't know the distribution yet]
            energy = analogsig/gain
            scattered = analogsignal(angle, energy, gain)
            signal = analogsig - scattered
            tot_signal = signal + noise_signal

            if tot_signal < 0:
                continue #not physical result

            bin_val = np.floor((2 ** bit_depth) * tot_signal / max_signal)

            bins[bin_val] += 1


        elif backprob_n <= probback: # chance of passing through the scintillating crystal
            backsignal = backscatter(analogsig/gain, gain)
            tot_signal = backsignal + noise_signal
            if tot_signal < 0:
                continue  # not physical result
            bin_val = np.floor((2 ** bit_depth) * tot_signal / max_signal)

            bins[bin_val] += 1
        else:

            tot_signal = analogsig + noise_signal

            bin_val = np.floor((2 ** bit_depth) * tot_signal / max_signal)

            bins[bin_val] += 1

    return bins

# Detector info
gain1 = 2.85e-3
gain2 = 5e-3

# Experimental parameters
scatter_angle = 30
source_energy = 662

e_energy = 511

analsig1 = analogsignal(scatter_angle, source_energy, gain1, e_energy)
analsig2 = analogsignal(scatter_angle, source_energy, gain2, e_energy)

channels = generate_noise(1000, analsig1, gain1)
cannale2 = generate_noise(1000, analsig2, gain2)

plt.scatter(channels.keys(), channels.values(), label = "Gain = 0.00285")
plt.scatter(cannale2.keys(), cannale2.values(), label = "Gain = 0.005")
plt.title("Simulated signal for " + str(scatter_angle) + " degrees")
plt.legend()
plt.xlabel("Channel")
plt.ylabel("Counts")
plt.grid()

#%%
backscattest = generate_noise(10000, analsig1, gain1, probback= 0.05 )
channels = generate_noise(10000, analsig1, gain1)

plt.figure()
plt.scatter(backscattest.keys(), backscattest.values(), label = "Backscatter incl")
#plt.scatter(channels.keys(), channels.values(), label = "No backscatter")
plt.legend()
plt.xlabel("Channel")
plt.ylabel("Counts")
plt.grid()


comptonedgetest = generate_noise(10000, analsig1, gain1, scat_prob = 0.1)
channels = generate_noise(10000, analsig1, gain1)

plt.figure()
plt.scatter(comptonedgetest.keys(),comptonedgetest.values(), label = "Compton edge")
#plt.scatter(channels.keys(), channels.values(), label = "No compton edge")
plt.legend()
plt.xlabel("Channel")
plt.ylabel("Counts")
plt.grid()


botheffects = generate_noise(10000, analsig1, gain1, probback = 0.2, scat_prob = 0.2)

plt.figure()
plt.scatter(botheffects.keys(), botheffects.values())
plt.title("Including both Compton effect and backscattering")
plt.xlabel("Channel")
plt.ylabel("Counts")
plt.grid()



















